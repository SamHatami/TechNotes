[{"content":"The goal is to create a shader each week, doesn\u0026rsquo;t matter how simple or complex, as long as I keep going on. No AI, just documentation and tutorials.\nThis time around I\u0026rsquo;ll try and make a grid, inspired by the book of shaders https://thebookofshaders.com/edit.php#10/ikeda-simple-grid.frag\nWhat it does gl_FragCoord.xy/u_resolution.xy normalizes the pixel coordinates into the range [0.0-1.0] fract(st * res) return st*res - floor(st*res), which basically creates this step(t, grid.x) and step(t, grid.y) returns 0 if grid.x || grid.y is \u0026lt; 0 and 1 if otherwise 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 precision mediump float; uniform vec2 u_resolution; float scale = 400.0; float l_thickness = 0.01; float grid(vec2 st, float res, float t){ vec2 grid = fract(st * res); return 1.-(step(t,grid.x) * step(t,grid.y)); } void main() { vec2 st = gl_FragCoord.xy/u_resolution.xy; vec3 color = vec3(0.0); vec2 grid_scale = st*scale; // scale color += vec3(0.5725, 0.5725, 0.5725)*grid(grid_scale,0.04, l_thickness); gl_FragColor = vec4(color,1.0); } ","date":"2025-06-01T00:00:00Z","permalink":"https://samhatami.github.io/TechNotes/p/shader-of-the-week-2/","title":"Shader Of The Week - 2"},{"content":"The goal is to create a shader each week, doesn\u0026rsquo;t matter how simple or complex, as long as I keep going on. No AI, just documentation and tutorials.\nThis one is just a simple horisontal movement. Yay!\nWhat it does gl_FragCoord.xy/u_resolution.xy normalizes the pixel coordinates into the range [0.0-1.0] sin(st.x*PI-u_time) creates a wave-pattern that depends on the horizontal coordinate and time (negative time means it\u0026rsquo;ll move left to right). PI adjusts the wave to move one cycle across the view. 1 2 3 4 5 6 7 8 9 10 11 12 precision mediump float; uniform vec2 u_resolution; uniform float u_time; float PI = 3.14159; void main() { vec2 st = gl_FragCoord.xy/u_resolution.xy; vec3 color = vec3(sin(st.x*PI-u_time)); gl_FragColor = vec4(color, 1.0); } ","date":"2025-05-21T00:00:00Z","permalink":"https://samhatami.github.io/TechNotes/p/shader-of-the-week-1/","title":"Shader Of The Week - 1"},{"content":"A direct translation of Method of Joints in matrix form is to solve all local joint equillibrium equations in \u0026ldquo;one\u0026rdquo; go. This is a key advantage when going for automation.\nMatrix formulation The goal is to solve the matrix operation, which is for statically determined trusses.\n$$ x = A^{-1}b $$ Where\nb is a collection of our externally known forces. A is a collection of known normalized member directions. x is the collection of unknown forces and reactions. Matrix Construction Requirements To perform matrix operations, we need a square matrix. Each row corresponds to force equilibrium equations, with coefficients representing the directional contribution of each member at the joints. Most entries will be zero except where members connect to joints.\nThe global matrix dimensions are:\nRows = Number of Nodes Ã— 2 (representing force equilibrium in both x and y directions) Columns = Number of Members + Total Number of Supports This directly relates to the condition for a statically determinate structure: $$ members+reactions=2*nodes $$If the truss is unstable matrix A will become rectangular and thus has no solution, i.e it indicates a Mechanism.\nBuilding the Coefficient Matrix When constructing the global matrix, we only consider the joints and external loading. The coefficients are the normalized directional components of each member, representing their orientation in 2D space. The sign convention used here are assuming positive member forces equals tension.\nFor example:\nMember 1\u0026rsquo;s normalized direction might be (1,0), representing a horizontal member Each row represents equilibrium at a specific node in a specific direction Consider the example\nADD EXAMPLE PICS AND MATRICES\nSolving by code Math.Net Numerics\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 public static double[,] BuildGlobalMatrix(this TrussStructure structure, Dictionary\u0026lt;int, int\u0026gt; nodeIndexMap) { var nrOfRows = structure.Nodes.Count * 2; var nrOfColumns = structure.Members.Count + structure.TotalReactionComponents(); var matrix = new double[nrOfRows, nrOfColumns]; if (nodeIndexMap == null) nodeIndexMap = structure.BuildNodeIndexMap(); for (var i = 0; i \u0026lt; structure.Members.Count; i++) { var startNodeIndex = nodeIndexMap[structure.Members[i].Start.Id]; var endNodeIndex = nodeIndexMap[structure.Members[i].End.Id]; var member = structure.Members[i]; matrix[2 * startNodeIndex, i] = member.Direction.X; matrix[2 * startNodeIndex + 1, i] = member.Direction.Y; matrix[2 * endNodeIndex, i] = -member.Direction.X; matrix[2 * endNodeIndex + 1, i] = -member.Direction.Y; } var reactionIndex = structure.Members.Count; foreach (var support in structure.Supports) { var supportNodeIndex = nodeIndexMap[support.NodeData.Id]; //The enum here is redundant, but kept for clarity. //user should be able to set the degree of freedom for each support and the global matrix should be built accordingly. //Pre-defined support types are just a convenience. //user will be able to set DoF for each support in the future in the GUI if (support.BoundaryCondition.Type == BoundaryConditionType.Pinned) { matrix[2 * supportNodeIndex, reactionIndex] = 1; matrix[2 * supportNodeIndex + 1, reactionIndex + 1] = 1; reactionIndex += 2; } else if (support.BoundaryCondition.Type == BoundaryConditionType.Roller) //Should be allowed to set x or y to be free, or angled? { //TODO: Improve next pass. if (support.DegreeOfFreedom.Ux) matrix[2 * supportNodeIndex, reactionIndex] = 1; else if (support.DegreeOfFreedom.Uy) matrix[2 * supportNodeIndex + 1, reactionIndex] = 1; reactionIndex++; } } return matrix; } Code on a simple 2D solver ","date":"2025-04-27T00:00:00Z","permalink":"https://samhatami.github.io/TechNotes/p/matrix-methods-of-joints/","title":"Matrix Methods of Joints"}]